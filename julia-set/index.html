<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Julia Set Explorer</title>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&family=DM+Sans:wght@400;500;600&display=swap" rel="stylesheet">
  <style>
    *, *::before, *::after { margin: 0; padding: 0; box-sizing: border-box; }

    :root {
      --bg: #0a0a0f;
      --panel: #12121a;
      --border: #2a2a3a;
      --accent: #00e5ff;
      --accent-dim: rgba(0, 229, 255, 0.3);
      --amber: #ffab00;
      --amber-dim: rgba(255, 171, 0, 0.3);
      --text: #e0e0e8;
      --text-dim: #8888a0;
      --mono: 'JetBrains Mono', monospace;
      --sans: 'DM Sans', sans-serif;
    }

    body {
      background: var(--bg);
      color: var(--text);
      font-family: var(--sans);
      overflow: hidden;
      height: 100vh;
      width: 100vw;
    }

    /* === Toolbar === */
    #toolbar {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 8px 16px;
      background: var(--panel);
      border-bottom: 1px solid var(--border);
      height: 44px;
      z-index: 100;
    }

    #toolbar button {
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text);
      font-family: var(--sans);
      font-size: 12px;
      padding: 4px 12px;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.15s;
    }

    #toolbar button:hover {
      border-color: var(--accent);
      color: var(--accent);
      background: rgba(0, 229, 255, 0.05);
    }

    .toolbar-spacer { flex: 1; }

    .coord-display {
      font-family: var(--mono);
      font-size: 12px;
      color: var(--text-dim);
      letter-spacing: -0.3px;
    }

    .coord-display .value {
      color: var(--accent);
    }

    #c-display {
      font-family: var(--mono);
      font-size: 13px;
      font-weight: 500;
      color: var(--accent);
      letter-spacing: -0.3px;
    }

    /* === Main Layout === */
    #main {
      display: flex;
      height: calc(100vh - 44px);
    }

    #canvas-area {
      flex: 1;
      position: relative;
      overflow: hidden;
      background: var(--bg);
    }

    #julia-canvas {
      display: block;
      width: 100%;
      height: 100%;
      cursor: crosshair;
      box-shadow: inset 0 0 30px rgba(0, 229, 255, 0.04);
    }

    /* === Mandelbrot Navigator === */
    #mandelbrot-nav {
      position: absolute;
      bottom: 16px;
      left: 16px;
      width: 220px;
      height: 220px;
      background: rgba(18, 18, 26, 0.85);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border: 1px solid var(--border);
      border-radius: 8px;
      overflow: hidden;
      z-index: 50;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    }

    #mandelbrot-nav .nav-label {
      position: absolute;
      top: 4px;
      left: 8px;
      font-family: var(--sans);
      font-size: 10px;
      font-weight: 600;
      color: var(--text-dim);
      text-transform: uppercase;
      letter-spacing: 0.8px;
      z-index: 2;
      pointer-events: none;
    }

    #mandelbrot-canvas {
      width: 220px;
      height: 220px;
      cursor: crosshair;
    }

    #mandelbrot-nav.collapsed {
      width: 36px;
      height: 36px;
      border-radius: 6px;
      cursor: pointer;
    }

    #mandelbrot-nav.collapsed .nav-label,
    #mandelbrot-nav.collapsed #mandelbrot-canvas {
      display: none;
    }

    #nav-toggle {
      position: absolute;
      top: 4px;
      right: 4px;
      width: 20px;
      height: 20px;
      background: transparent;
      border: none;
      color: var(--text-dim);
      font-size: 14px;
      cursor: pointer;
      z-index: 3;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 3px;
    }

    #nav-toggle:hover { color: var(--accent); background: rgba(0,229,255,0.1); }

    #mandelbrot-nav.collapsed #nav-toggle {
      position: static;
      width: 36px;
      height: 36px;
      font-size: 18px;
    }

    /* === Control Panel === */
    #sidebar {
      width: 280px;
      min-width: 280px;
      background: var(--panel);
      border-left: 1px solid var(--border);
      overflow-y: auto;
      padding: 16px;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    #sidebar.hidden { display: none; }

    .section-label {
      font-family: var(--sans);
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
      color: var(--text-dim);
      margin-bottom: 10px;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .control-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .control-row label {
      font-family: var(--mono);
      font-size: 11px;
      color: var(--text-dim);
      min-width: 56px;
    }

    .control-row input[type="number"] {
      flex: 1;
      background: var(--bg);
      border: 1px solid var(--border);
      color: var(--text);
      font-family: var(--mono);
      font-size: 12px;
      padding: 4px 6px;
      border-radius: 4px;
      outline: none;
      width: 0;
    }

    .control-row input[type="number"]:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent-dim);
    }

    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      flex: 1;
      height: 4px;
      background: var(--border);
      border-radius: 2px;
      outline: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
      box-shadow: 0 0 6px var(--accent-dim);
    }

    .anim-range::-webkit-slider-thumb {
      background: var(--amber) !important;
      box-shadow: 0 0 6px var(--amber-dim) !important;
    }

    select {
      background: var(--bg);
      border: 1px solid var(--border);
      color: var(--text);
      font-family: var(--sans);
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 4px;
      outline: none;
      cursor: pointer;
      flex: 1;
    }

    select:focus { border-color: var(--accent); }

    .range-value {
      font-family: var(--mono);
      font-size: 11px;
      color: var(--accent);
      min-width: 40px;
      text-align: right;
    }

    /* === Animation Section === */
    .anim-section .section-label { color: var(--amber); }

    #btn-animate {
      background: transparent;
      border: 1px solid var(--amber);
      color: var(--amber);
      font-family: var(--sans);
      font-size: 12px;
      font-weight: 600;
      padding: 6px 16px;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.15s;
      width: 100%;
    }

    #btn-animate:hover {
      background: rgba(255, 171, 0, 0.1);
    }

    #btn-animate.active {
      background: var(--amber);
      color: #000;
    }

    /* === Preset Buttons === */
    .preset-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 4px;
    }

    .preset-btn {
      background: var(--bg);
      border: 1px solid var(--border);
      color: var(--text-dim);
      font-family: var(--sans);
      font-size: 10px;
      padding: 4px 6px;
      border-radius: 3px;
      cursor: pointer;
      transition: all 0.15s;
      text-align: center;
    }

    .preset-btn:hover {
      border-color: var(--accent);
      color: var(--accent);
    }

    /* === View Info === */
    .info-row {
      display: flex;
      justify-content: space-between;
      font-family: var(--mono);
      font-size: 11px;
    }

    .info-row .label { color: var(--text-dim); }
    .info-row .val { color: var(--accent); }

    /* === Palette Preview === */
    .palette-preview {
      height: 12px;
      border-radius: 2px;
      margin-top: 4px;
      background: linear-gradient(to right, #000, #00e5ff, #fff);
    }

    /* === Gradient Editor === */
    .ge-bar-wrap { position: relative; margin-bottom: 4px; }

    #ge-bar {
      width: 100%;
      height: 22px;
      border-radius: 4px;
      border: 1px solid var(--border);
      cursor: crosshair;
      background: linear-gradient(to right, #000, #fff);
    }

    #ge-stops {
      position: relative;
      height: 20px;
      margin-top: 2px;
    }

    .ge-stop {
      position: absolute;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      border: 2px solid rgba(255,255,255,0.7);
      transform: translateX(-50%);
      cursor: grab;
      box-shadow: 0 1px 4px rgba(0,0,0,0.6);
      top: 2px;
      transition: border-color 0.1s, box-shadow 0.1s;
    }

    .ge-stop:hover { border-color: #fff; }

    .ge-stop.selected {
      border-color: #b388ff;
      box-shadow: 0 0 0 2px rgba(179,136,255,0.35), 0 1px 4px rgba(0,0,0,0.6);
      z-index: 2;
    }

    .ge-btn-row { display: flex; gap: 6px; }

    .ge-btn {
      flex: 1;
      background: var(--bg);
      border: 1px solid var(--border);
      color: var(--text-dim);
      font-family: var(--sans);
      font-size: 11px;
      padding: 4px 8px;
      border-radius: 3px;
      cursor: pointer;
      transition: all 0.15s;
    }

    .ge-btn:hover { border-color: #b388ff; color: #b388ff; }
    .ge-btn-danger:hover { border-color: #ff5252; color: #ff5252; }

    .ge-btn-save {
      min-width: 50px;
      border-color: #b388ff;
      color: #b388ff;
    }

    .ge-btn-save:hover { background: rgba(179,136,255,0.1); }

    .ge-name-input {
      flex: 1;
      background: var(--bg);
      border: 1px solid var(--border);
      color: var(--text);
      font-family: var(--sans);
      font-size: 12px;
      padding: 4px 6px;
      border-radius: 4px;
      outline: none;
      transition: border-color 0.15s;
      min-width: 0;
    }

    .ge-name-input:focus { border-color: #b388ff; }

    .ge-divider { height: 1px; background: var(--border); margin: 4px 0; }

    .ge-saved-list {
      display: flex;
      flex-direction: column;
      gap: 4px;
      max-height: 140px;
      overflow-y: auto;
    }

    .ge-saved-row {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 3px 0;
    }

    .ge-saved-preview {
      width: 40px;
      height: 14px;
      border-radius: 2px;
      border: 1px solid var(--border);
      flex-shrink: 0;
    }

    .ge-saved-name {
      flex: 1;
      font-family: var(--sans);
      font-size: 11px;
      color: var(--text-dim);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      min-width: 0;
    }

    .ge-saved-btn {
      background: transparent;
      border: 1px solid var(--border);
      color: var(--text-dim);
      font-family: var(--sans);
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 3px;
      cursor: pointer;
      flex-shrink: 0;
      transition: all 0.15s;
    }

    .ge-saved-btn:hover { border-color: #b388ff; color: #b388ff; }
    .ge-saved-btn-del:hover { border-color: #ff5252; color: #ff5252; }

    .ge-empty {
      font-family: var(--sans);
      font-size: 11px;
      color: var(--text-dim);
      opacity: 0.5;
      text-align: center;
      padding: 4px;
    }

    input[type="color"] {
      -webkit-appearance: none;
      appearance: none;
      width: 32px;
      height: 24px;
      border: 1px solid var(--border);
      border-radius: 3px;
      background: transparent;
      cursor: pointer;
      padding: 1px;
    }

    input[type="color"]::-webkit-color-swatch-wrapper { padding: 1px; }
    input[type="color"]::-webkit-color-swatch { border: none; border-radius: 2px; }

    /* === Sidebar Toggle === */
    #sidebar-toggle {
      position: absolute;
      top: 50%;
      right: 0;
      transform: translateY(-50%);
      width: 20px;
      height: 48px;
      background: var(--panel);
      border: 1px solid var(--border);
      border-right: none;
      border-radius: 6px 0 0 6px;
      color: var(--text-dim);
      cursor: pointer;
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      z-index: 60;
    }

    #sidebar-toggle:hover { color: var(--accent); }
    #sidebar.hidden ~ #sidebar-toggle,
    .sidebar-collapsed #sidebar-toggle { display: flex; }

    /* === Fullscreen Overlay === */
    .fullscreen-mode #toolbar,
    .fullscreen-mode #sidebar {
      display: none !important;
    }

    .fullscreen-mode #main {
      height: 100vh;
    }

    .fullscreen-mode #mandelbrot-nav {
      bottom: 20px;
      left: 20px;
    }

    #fullscreen-exit {
      display: none;
      position: absolute;
      top: 12px;
      right: 12px;
      background: rgba(18, 18, 26, 0.85);
      backdrop-filter: blur(8px);
      border: 1px solid var(--border);
      color: var(--text-dim);
      font-family: var(--sans);
      font-size: 11px;
      padding: 6px 12px;
      border-radius: 4px;
      cursor: pointer;
      z-index: 100;
    }

    #fullscreen-exit:hover { color: var(--accent); border-color: var(--accent); }
    .fullscreen-mode #fullscreen-exit { display: block; }

    #fullscreen-coords {
      display: none;
      position: absolute;
      top: 12px;
      left: 12px;
      font-family: var(--mono);
      font-size: 12px;
      color: var(--accent);
      background: rgba(18, 18, 26, 0.85);
      backdrop-filter: blur(8px);
      padding: 6px 12px;
      border-radius: 4px;
      border: 1px solid var(--border);
      z-index: 100;
      pointer-events: none;
    }

    .fullscreen-mode #fullscreen-coords { display: block; }

    /* === Loading Overlay === */
    #loading {
      position: absolute;
      top: 8px;
      right: 8px;
      font-family: var(--mono);
      font-size: 10px;
      color: var(--accent);
      opacity: 0;
      transition: opacity 0.15s;
      pointer-events: none;
      z-index: 60;
    }

    #loading.active { opacity: 1; }

    /* === Responsive === */
    @media (max-width: 900px) {
      #sidebar { width: 240px; min-width: 240px; padding: 12px; }
      #mandelbrot-nav { width: 180px; height: 180px; }
      #mandelbrot-canvas { width: 180px; height: 180px; }
    }

    @media (max-width: 700px) {
      #sidebar { display: none; }
      #mandelbrot-nav { width: 150px; height: 150px; }
      #mandelbrot-canvas { width: 150px; height: 150px; }
    }

    /* Scrollbar styling */
    #sidebar::-webkit-scrollbar { width: 4px; }
    #sidebar::-webkit-scrollbar-track { background: transparent; }
    #sidebar::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }
  </style>
</head>
<body>

  <!-- Toolbar -->
  <div id="toolbar">
    <button id="btn-reset" title="Reset view">Reset</button>
    <button id="btn-fullscreen" title="Toggle fullscreen">Fullscreen</button>
    <div class="toolbar-spacer"></div>
    <span class="coord-display" id="z-display">z = <span class="value">0.0000 + 0.0000i</span></span>
    <span style="color: var(--border); margin: 0 4px;">|</span>
    <span id="c-display">c = -0.7269 + 0.1889i</span>
  </div>

  <!-- Main Layout -->
  <div id="main">
    <!-- Canvas Area -->
    <div id="canvas-area">
      <canvas id="julia-canvas"></canvas>

      <!-- Mandelbrot Navigator -->
      <div id="mandelbrot-nav">
        <span class="nav-label">Mandelbrot</span>
        <button id="nav-toggle" title="Toggle navigator">&times;</button>
        <canvas id="mandelbrot-canvas"></canvas>
      </div>

      <!-- Fullscreen overlays -->
      <button id="fullscreen-exit">Exit Fullscreen</button>
      <div id="fullscreen-coords"></div>
      <div id="loading">rendering...</div>
    </div>

    <!-- Control Panel Sidebar -->
    <div id="sidebar">
      <!-- C Parameter -->
      <div class="control-group">
        <div class="section-label">Complex Parameter (c)</div>
        <div class="control-row">
          <label>Real</label>
          <input type="number" id="c-real" step="0.001" min="-2" max="2" value="-0.7269">
        </div>
        <div class="control-row">
          <label>Imag</label>
          <input type="number" id="c-imag" step="0.001" min="-2" max="2" value="0.1889">
        </div>
        <div class="section-label" style="margin-top:4px; margin-bottom:4px;">Presets</div>
        <div class="preset-grid">
          <button class="preset-btn" data-re="-0.7269" data-im="0.1889">Dendrite</button>
          <button class="preset-btn" data-re="-0.8" data-im="0.156">Douady Rabbit</button>
          <button class="preset-btn" data-re="0.285" data-im="0.01">Spiral Galaxy</button>
          <button class="preset-btn" data-re="-0.4" data-im="0.6">Dragon</button>
          <button class="preset-btn" data-re="0.355" data-im="0.355">Filaments</button>
          <button class="preset-btn" data-re="-0.54" data-im="0.54">Star Burst</button>
        </div>
      </div>

      <!-- Rendering -->
      <div class="control-group">
        <div class="section-label">Rendering</div>
        <div class="control-row">
          <label>Iterations</label>
          <input type="range" id="iterations-slider" min="50" max="2000" value="300">
          <span class="range-value" id="iterations-val">300</span>
        </div>
        <div class="control-row">
          <label>Palette</label>
          <select id="palette-select">
            <option value="smoothHSL">Smooth HSL</option>
            <option value="classic">Classic</option>
            <option value="fire">Fire</option>
            <option value="ocean">Ocean</option>
            <option value="monochrome">Monochrome</option>
            <option value="psychedelic">Psychedelic</option>
            <option value="custom">Custom...</option>
          </select>
        </div>
        <div class="palette-preview" id="palette-preview"></div>
      </div>

      <!-- Custom Gradient Editor -->
      <div class="control-group" id="gradient-editor" style="display:none;">
        <div class="section-label" style="color:#b388ff;">Custom Gradient</div>
        <div class="ge-bar-wrap">
          <div class="ge-bar" id="ge-bar"></div>
          <div class="ge-stops" id="ge-stops"></div>
        </div>
        <div class="control-row">
          <label>Color</label>
          <input type="color" id="ge-color" value="#00e5ff">
          <label style="min-width:24px;">Pos</label>
          <span class="range-value" id="ge-pos-val" style="color:#b388ff;">0.00</span>
        </div>
        <div class="ge-btn-row">
          <button class="ge-btn" id="ge-add-stop">+ Add Stop</button>
          <button class="ge-btn ge-btn-danger" id="ge-del-stop">Remove</button>
        </div>
        <div class="ge-divider"></div>
        <div class="control-row">
          <input type="text" id="ge-name" placeholder="Gradient name..." class="ge-name-input">
          <button class="ge-btn ge-btn-save" id="ge-save">Save</button>
        </div>
        <div id="ge-saved-list" class="ge-saved-list"></div>
      </div>

      <!-- View Info -->
      <div class="control-group">
        <div class="section-label">View</div>
        <div class="info-row">
          <span class="label">Zoom</span>
          <span class="val" id="zoom-val">1.00x</span>
        </div>
        <div class="info-row">
          <span class="label">Center</span>
          <span class="val" id="center-val">0.0000, 0.0000</span>
        </div>
        <button id="btn-reset-view" style="margin-top:4px;background:var(--bg);border:1px solid var(--border);color:var(--text-dim);font-size:11px;padding:4px 8px;border-radius:3px;cursor:pointer;font-family:var(--sans);">Reset View</button>
      </div>

      <!-- Animation -->
      <div class="control-group anim-section">
        <div class="section-label">Animation</div>
        <button id="btn-animate">Play</button>
        <div class="control-row">
          <label>Path</label>
          <select id="anim-path">
            <option value="circle">Circle</option>
            <option value="cardioid">Cardioid</option>
            <option value="lemniscate">Lemniscate</option>
            <option value="custom">Custom Lerp</option>
          </select>
        </div>
        <div class="control-row">
          <label>Speed</label>
          <input type="range" class="anim-range" id="anim-speed" min="0.0005" max="0.01" step="0.0005" value="0.002">
          <span class="range-value" style="color:var(--amber)" id="speed-val">0.002</span>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ================================================================
    // === STATE ===
    // ================================================================
    const state = {
      c: { re: -0.7269, im: 0.1889 },
      tempC: null,
      julia: {
        center: { re: 0, im: 0 },
        zoom: 4,
        maxIterations: 300
      },
      mandelbrot: {
        center: { re: -0.5, im: 0 },
        zoom: 3.5
      },
      palette: 'smoothHSL',
      animation: {
        active: false,
        path: 'circle',
        speed: 0.002,
        t: 0
      },
      fullscreen: false,
      customGradient: {
        stops: [
          { pos: 0, color: [0, 0, 40] },
          { pos: 0.25, color: [180, 0, 255] },
          { pos: 0.5, color: [0, 229, 255] },
          { pos: 0.75, color: [255, 200, 0] },
          { pos: 1, color: [255, 255, 255] }
        ],
        selectedIndex: 0
      }
    };

    // ================================================================
    // === DOM REFS ===
    // ================================================================
    const juliaCanvas = document.getElementById('julia-canvas');
    const juliaCtx = juliaCanvas.getContext('2d');
    const mandelbrotCanvas = document.getElementById('mandelbrot-canvas');
    const mandelbrotCtx = mandelbrotCanvas.getContext('2d');

    // Controls
    const cRealInput = document.getElementById('c-real');
    const cImagInput = document.getElementById('c-imag');
    const iterSlider = document.getElementById('iterations-slider');
    const iterVal = document.getElementById('iterations-val');
    const paletteSelect = document.getElementById('palette-select');
    const palettePreview = document.getElementById('palette-preview');
    const zoomVal = document.getElementById('zoom-val');
    const centerVal = document.getElementById('center-val');
    const animBtn = document.getElementById('btn-animate');
    const animPath = document.getElementById('anim-path');
    const animSpeed = document.getElementById('anim-speed');
    const speedVal = document.getElementById('speed-val');
    const zDisplay = document.getElementById('z-display');
    const cDisplay = document.getElementById('c-display');
    const loadingEl = document.getElementById('loading');
    const fullscreenCoords = document.getElementById('fullscreen-coords');

    // ================================================================
    // === COLOR PALETTES ===
    // ================================================================
    function hslToRgb(h, s, l) {
      let r, g, b;
      if (s === 0) {
        r = g = b = l;
      } else {
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        };
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
      }
      return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    }

    function lerpColor(c1, c2, t) {
      return [
        Math.round(c1[0] + (c2[0] - c1[0]) * t),
        Math.round(c1[1] + (c2[1] - c1[1]) * t),
        Math.round(c1[2] + (c2[2] - c1[2]) * t)
      ];
    }

    function gradientPalette(stops, smooth) {
      const t = ((smooth * 0.02) % 1 + 1) % 1;
      const n = stops.length - 1;
      const idx = t * n;
      const i = Math.floor(idx);
      const f = idx - i;
      return lerpColor(stops[Math.min(i, n)], stops[Math.min(i + 1, n)], f);
    }

    const palettes = {
      smoothHSL(smooth) {
        const hue = ((smooth * 8 + 200) % 360) / 360;
        const sat = 0.75 + 0.2 * Math.sin(smooth * 0.12);
        const light = 0.5 + 0.1 * Math.cos(smooth * 0.08);
        return hslToRgb(hue, Math.max(0, Math.min(1, sat)), Math.max(0.1, Math.min(0.7, light)));
      },
      classic(smooth) {
        return gradientPalette([
          [0, 7, 100], [32, 107, 203], [237, 255, 255],
          [255, 170, 0], [200, 82, 0], [0, 7, 100]
        ], smooth);
      },
      fire(smooth) {
        return gradientPalette([
          [0, 0, 0], [128, 0, 0], [255, 80, 0],
          [255, 200, 0], [255, 255, 180], [255, 200, 0],
          [128, 0, 0], [0, 0, 0]
        ], smooth);
      },
      ocean(smooth) {
        return gradientPalette([
          [0, 0, 30], [0, 30, 80], [0, 80, 160],
          [0, 170, 210], [120, 230, 255], [240, 255, 255],
          [0, 170, 210], [0, 30, 80]
        ], smooth);
      },
      monochrome(smooth) {
        const t = ((smooth * 0.03) % 1 + 1) % 1;
        const v = Math.round(t * 255);
        return [v, v, v];
      },
      psychedelic(smooth) {
        const hue = ((smooth * 30) % 360) / 360;
        return hslToRgb(hue, 1.0, 0.5);
      },
      custom(smooth) {
        const stops = state.customGradient.stops;
        if (stops.length === 0) return [0, 0, 0];
        if (stops.length === 1) return [...stops[0].color];
        const t = ((smooth * 0.02) % 1 + 1) % 1;
        if (t <= stops[0].pos) return [...stops[0].color];
        if (t >= stops[stops.length - 1].pos) return [...stops[stops.length - 1].color];
        let i = 0;
        while (i < stops.length - 1 && stops[i + 1].pos <= t) i++;
        const s1 = stops[i];
        const s2 = stops[i + 1];
        if (s2.pos === s1.pos) return [...s1.color];
        const f = (t - s1.pos) / (s2.pos - s1.pos);
        return lerpColor(s1.color, s2.color, Math.max(0, Math.min(1, f)));
      }
    };

    function buildPalettePreviewGradient(name) {
      const stops = [];
      for (let i = 0; i <= 20; i++) {
        const s = i * 15;
        const [r, g, b] = palettes[name](s);
        stops.push(`rgb(${r},${g},${b}) ${(i / 20 * 100).toFixed(0)}%`);
      }
      return `linear-gradient(to right, ${stops.join(', ')})`;
    }

    // ================================================================
    // === ANIMATION PATHS ===
    // ================================================================
    const animPaths = {
      circle(t) {
        const theta = t * Math.PI * 2;
        return { re: 0.7885 * Math.cos(theta), im: 0.7885 * Math.sin(theta) };
      },
      cardioid(t) {
        const theta = t * Math.PI * 2;
        const re = 0.5 * Math.cos(theta) - 0.25 * Math.cos(2 * theta);
        const im = 0.5 * Math.sin(theta) - 0.25 * Math.sin(2 * theta);
        return { re, im };
      },
      lemniscate(t) {
        const theta = t * Math.PI * 2;
        const s = Math.sin(theta);
        const c = Math.cos(theta);
        const denom = 1 + s * s;
        return { re: 1.0 * c / denom, im: 1.0 * s * c / denom };
      },
      custom(t) {
        const start = { re: -0.8, im: 0.156 };
        const end = { re: 0.285, im: 0.01 };
        const p = (Math.sin(t * Math.PI * 2 - Math.PI / 2) + 1) / 2;
        return {
          re: start.re + (end.re - start.re) * p,
          im: start.im + (end.im - start.im) * p
        };
      }
    };

    // ================================================================
    // === FRACTAL MATH ===
    // ================================================================
    function juliaIterate(zRe, zIm, cRe, cIm, maxIter) {
      let re = zRe, im = zIm;
      for (let n = 0; n < maxIter; n++) {
        const re2 = re * re;
        const im2 = im * im;
        if (re2 + im2 > 65536) {
          const logZn = 0.5 * Math.log(re2 + im2);
          return n + 1 - Math.log(logZn / Math.LN2) / Math.LN2;
        }
        im = 2 * re * im + cIm;
        re = re2 - im2 + cRe;
      }
      return -1;
    }

    function mandelbrotIterate(cRe, cIm, maxIter) {
      let re = 0, im = 0;
      for (let n = 0; n < maxIter; n++) {
        const re2 = re * re;
        const im2 = im * im;
        if (re2 + im2 > 65536) {
          const logZn = 0.5 * Math.log(re2 + im2);
          return n + 1 - Math.log(logZn / Math.LN2) / Math.LN2;
        }
        im = 2 * re * im + cIm;
        re = re2 - im2 + cRe;
      }
      return -1;
    }

    // ================================================================
    // === PIXEL <-> COMPLEX MAPPING ===
    // ================================================================
    function pixelToComplex(px, py, canvasW, canvasH, view) {
      const aspect = canvasW / canvasH;
      const re = view.center.re + (px / canvasW - 0.5) * view.zoom * aspect;
      const im = view.center.im - (py / canvasH - 0.5) * view.zoom;
      return { re, im };
    }

    function complexToPixel(re, im, canvasW, canvasH, view) {
      const aspect = canvasW / canvasH;
      const px = ((re - view.center.re) / (view.zoom * aspect) + 0.5) * canvasW;
      const py = (-(im - view.center.im) / view.zoom + 0.5) * canvasH;
      return { x: px, y: py };
    }

    // ================================================================
    // === RENDERING ===
    // ================================================================
    let juliaRenderID = 0;
    let qualityTimeout = null;
    let mandelbrotCachedData = null;

    function renderJulia(quality) {
      const renderID = ++juliaRenderID;
      const canvas = juliaCanvas;
      const ctx = juliaCtx;
      const w = canvas.width;
      const h = canvas.height;

      if (w === 0 || h === 0) return;

      const step = quality || 1;
      const c = state.tempC || state.c;
      const view = state.julia;
      const maxIter = view.maxIterations;
      const palFn = palettes[state.palette];

      const imageData = ctx.createImageData(w, h);
      const data = imageData.data;
      const aspect = w / h;

      for (let py = 0; py < h; py += step) {
        if (juliaRenderID !== renderID) return;
        for (let px = 0; px < w; px += step) {
          const zRe = view.center.re + (px / w - 0.5) * view.zoom * aspect;
          const zIm = view.center.im - (py / h - 0.5) * view.zoom;

          const smooth = juliaIterate(zRe, zIm, c.re, c.im, maxIter);

          let r = 0, g = 0, b = 0;
          if (smooth >= 0) {
            [r, g, b] = palFn(smooth);
          }

          for (let dy = 0; dy < step && py + dy < h; dy++) {
            for (let dx = 0; dx < step && px + dx < w; dx++) {
              const idx = ((py + dy) * w + (px + dx)) * 4;
              data[idx] = r;
              data[idx + 1] = g;
              data[idx + 2] = b;
              data[idx + 3] = 255;
            }
          }
        }
      }

      if (juliaRenderID === renderID) {
        ctx.putImageData(imageData, 0, 0);
      }
    }

    function scheduleJuliaRender(interacting) {
      juliaRenderID++;
      if (qualityTimeout) {
        clearTimeout(qualityTimeout);
        qualityTimeout = null;
      }

      if (interacting) {
        requestAnimationFrame(() => renderJulia(4));
        qualityTimeout = setTimeout(() => {
          requestAnimationFrame(() => renderJulia(1));
        }, 180);
      } else {
        loadingEl.classList.add('active');
        requestAnimationFrame(() => {
          renderJulia(1);
          loadingEl.classList.remove('active');
        });
      }
    }

    function renderMandelbrot() {
      const canvas = mandelbrotCanvas;
      const w = canvas.width;
      const h = canvas.height;
      if (w === 0 || h === 0) return;

      const ctx = mandelbrotCtx;
      const view = state.mandelbrot;
      const maxIter = 200;
      const palFn = palettes[state.palette];

      const imageData = ctx.createImageData(w, h);
      const data = imageData.data;
      const aspect = w / h;

      for (let py = 0; py < h; py++) {
        for (let px = 0; px < w; px++) {
          const cRe = view.center.re + (px / w - 0.5) * view.zoom * aspect;
          const cIm = view.center.im - (py / h - 0.5) * view.zoom;

          const smooth = mandelbrotIterate(cRe, cIm, maxIter);

          const idx = (py * w + px) * 4;
          if (smooth >= 0) {
            const [r, g, b] = palFn(smooth);
            data[idx] = r;
            data[idx + 1] = g;
            data[idx + 2] = b;
          }
          data[idx + 3] = 255;
        }
      }

      mandelbrotCachedData = imageData;
      ctx.putImageData(imageData, 0, 0);
      drawMandelbrotCrosshair();
    }

    function drawMandelbrotCrosshair() {
      if (!mandelbrotCachedData) return;
      const canvas = mandelbrotCanvas;
      const ctx = mandelbrotCtx;
      const w = canvas.width;
      const h = canvas.height;

      ctx.putImageData(mandelbrotCachedData, 0, 0);

      const c = state.c;
      const pos = complexToPixel(c.re, c.im, w, h, state.mandelbrot);

      ctx.strokeStyle = '#00e5ff';
      ctx.lineWidth = 1.5;
      ctx.shadowColor = '#00e5ff';
      ctx.shadowBlur = 6;
      ctx.beginPath();
      ctx.moveTo(pos.x - 8, pos.y);
      ctx.lineTo(pos.x + 8, pos.y);
      ctx.moveTo(pos.x, pos.y - 8);
      ctx.lineTo(pos.x, pos.y + 8);
      ctx.stroke();

      ctx.beginPath();
      ctx.arc(pos.x, pos.y, 3, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(0, 229, 255, 0.6)';
      ctx.fill();

      ctx.shadowBlur = 0;
    }

    // ================================================================
    // === CANVAS SIZING ===
    // ================================================================
    function resizeCanvases() {
      const area = document.getElementById('canvas-area');
      juliaCanvas.width = area.clientWidth;
      juliaCanvas.height = area.clientHeight;

      const navEl = document.getElementById('mandelbrot-nav');
      const navSize = navEl.classList.contains('collapsed') ? 0 :
        parseInt(getComputedStyle(mandelbrotCanvas).width);
      if (navSize > 0) {
        mandelbrotCanvas.width = navSize;
        mandelbrotCanvas.height = navSize;
      }
    }

    // ================================================================
    // === PAN & ZOOM ===
    // ================================================================
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    let dragCenter = { re: 0, im: 0 };

    juliaCanvas.addEventListener('mousedown', (e) => {
      if (e.button !== 0) return;
      isDragging = true;
      dragStart = { x: e.clientX, y: e.clientY };
      dragCenter = { ...state.julia.center };
      juliaCanvas.style.cursor = 'grabbing';
    });

    window.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      const dx = e.clientX - dragStart.x;
      const dy = e.clientY - dragStart.y;
      const w = juliaCanvas.width;
      const h = juliaCanvas.height;
      const aspect = w / h;

      state.julia.center.re = dragCenter.re - (dx / w) * state.julia.zoom * aspect;
      state.julia.center.im = dragCenter.im + (dy / h) * state.julia.zoom;

      updateViewInfo();
      scheduleJuliaRender(true);
    });

    window.addEventListener('mouseup', () => {
      if (isDragging) {
        isDragging = false;
        juliaCanvas.style.cursor = 'crosshair';
        scheduleJuliaRender(false);
      }
    });

    juliaCanvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      const rect = juliaCanvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const w = juliaCanvas.width;
      const h = juliaCanvas.height;

      const beforeZ = pixelToComplex(mx, my, w, h, state.julia);
      const factor = e.deltaY > 0 ? 1.12 : 1 / 1.12;
      state.julia.zoom *= factor;

      const afterZ = pixelToComplex(mx, my, w, h, state.julia);
      state.julia.center.re += beforeZ.re - afterZ.re;
      state.julia.center.im += beforeZ.im - afterZ.im;

      updateViewInfo();
      scheduleJuliaRender(true);
      clearTimeout(zoomEndTimeout);
      zoomEndTimeout = setTimeout(() => scheduleJuliaRender(false), 200);
    }, { passive: false });

    let zoomEndTimeout = null;

    // Touch support
    let touchStartDist = 0;
    let touchStartZoom = 0;
    let touchStartCenter = { re: 0, im: 0 };
    let singleTouchStart = null;

    juliaCanvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      if (e.touches.length === 1) {
        singleTouchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        dragCenter = { ...state.julia.center };
      } else if (e.touches.length === 2) {
        singleTouchStart = null;
        const dx = e.touches[1].clientX - e.touches[0].clientX;
        const dy = e.touches[1].clientY - e.touches[0].clientY;
        touchStartDist = Math.sqrt(dx * dx + dy * dy);
        touchStartZoom = state.julia.zoom;
        touchStartCenter = { ...state.julia.center };
      }
    }, { passive: false });

    juliaCanvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      if (e.touches.length === 1 && singleTouchStart) {
        const dx = e.touches[0].clientX - singleTouchStart.x;
        const dy = e.touches[0].clientY - singleTouchStart.y;
        const w = juliaCanvas.width;
        const h = juliaCanvas.height;
        const aspect = w / h;
        state.julia.center.re = dragCenter.re - (dx / w) * state.julia.zoom * aspect;
        state.julia.center.im = dragCenter.im + (dy / h) * state.julia.zoom;
        updateViewInfo();
        scheduleJuliaRender(true);
      } else if (e.touches.length === 2) {
        const dx = e.touches[1].clientX - e.touches[0].clientX;
        const dy = e.touches[1].clientY - e.touches[0].clientY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const scale = touchStartDist / dist;
        state.julia.zoom = touchStartZoom * scale;
        updateViewInfo();
        scheduleJuliaRender(true);
      }
    }, { passive: false });

    juliaCanvas.addEventListener('touchend', (e) => {
      singleTouchStart = null;
      scheduleJuliaRender(false);
    });

    // Coordinate display on hover
    juliaCanvas.addEventListener('mousemove', (e) => {
      if (isDragging) return;
      const rect = juliaCanvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const z = pixelToComplex(mx, my, juliaCanvas.width, juliaCanvas.height, state.julia);
      const zStr = formatComplex(z.re, z.im);
      zDisplay.innerHTML = `z = <span class="value">${zStr}</span>`;
      fullscreenCoords.textContent = `z = ${zStr}  |  c = ${formatComplex(state.c.re, state.c.im)}`;
    });

    // ================================================================
    // === MANDELBROT NAVIGATOR INTERACTION ===
    // ================================================================
    let mandelbrotHoverThrottle = null;

    mandelbrotCanvas.addEventListener('mousemove', (e) => {
      if (state.animation.active) return;
      if (mandelbrotHoverThrottle) return;

      mandelbrotHoverThrottle = setTimeout(() => {
        mandelbrotHoverThrottle = null;
      }, 60);

      const rect = mandelbrotCanvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const scaleX = mandelbrotCanvas.width / rect.width;
      const scaleY = mandelbrotCanvas.height / rect.height;
      const c = pixelToComplex(
        mx * scaleX, my * scaleY,
        mandelbrotCanvas.width, mandelbrotCanvas.height,
        state.mandelbrot
      );
      state.tempC = c;
      updateCDisplay(c);
      scheduleJuliaRender(true);
    });

    mandelbrotCanvas.addEventListener('click', (e) => {
      if (state.animation.active) return;
      const rect = mandelbrotCanvas.getBoundingClientRect();
      const mx = e.clientX - rect.left;
      const my = e.clientY - rect.top;
      const scaleX = mandelbrotCanvas.width / rect.width;
      const scaleY = mandelbrotCanvas.height / rect.height;
      const c = pixelToComplex(
        mx * scaleX, my * scaleY,
        mandelbrotCanvas.width, mandelbrotCanvas.height,
        state.mandelbrot
      );
      state.c = { ...c };
      state.tempC = null;
      cRealInput.value = c.re.toFixed(4);
      cImagInput.value = c.im.toFixed(4);
      updateCDisplay(c);
      drawMandelbrotCrosshair();
      scheduleJuliaRender(false);
    });

    mandelbrotCanvas.addEventListener('mouseleave', () => {
      if (state.tempC) {
        state.tempC = null;
        updateCDisplay(state.c);
        scheduleJuliaRender(false);
      }
    });

    // Navigator toggle
    document.getElementById('nav-toggle').addEventListener('click', (e) => {
      e.stopPropagation();
      const nav = document.getElementById('mandelbrot-nav');
      if (nav.classList.contains('collapsed')) {
        nav.classList.remove('collapsed');
        setTimeout(() => {
          resizeCanvases();
          renderMandelbrot();
        }, 50);
      } else {
        nav.classList.add('collapsed');
      }
    });

    document.getElementById('mandelbrot-nav').addEventListener('click', (e) => {
      const nav = document.getElementById('mandelbrot-nav');
      if (nav.classList.contains('collapsed')) {
        nav.classList.remove('collapsed');
        setTimeout(() => {
          resizeCanvases();
          renderMandelbrot();
        }, 50);
      }
    });

    // ================================================================
    // === CONTROLS ===
    // ================================================================
    cRealInput.addEventListener('input', () => {
      if (state.animation.active) return;
      state.c.re = parseFloat(cRealInput.value) || 0;
      updateCDisplay(state.c);
      drawMandelbrotCrosshair();
      scheduleJuliaRender(true);
    });

    cRealInput.addEventListener('change', () => scheduleJuliaRender(false));

    cImagInput.addEventListener('input', () => {
      if (state.animation.active) return;
      state.c.im = parseFloat(cImagInput.value) || 0;
      updateCDisplay(state.c);
      drawMandelbrotCrosshair();
      scheduleJuliaRender(true);
    });

    cImagInput.addEventListener('change', () => scheduleJuliaRender(false));

    iterSlider.addEventListener('input', () => {
      state.julia.maxIterations = parseInt(iterSlider.value);
      iterVal.textContent = iterSlider.value;
      scheduleJuliaRender(true);
    });

    iterSlider.addEventListener('change', () => scheduleJuliaRender(false));

    paletteSelect.addEventListener('change', () => {
      state.palette = paletteSelect.value;
      const isCustom = state.palette === 'custom';
      document.getElementById('gradient-editor').style.display = isCustom ? '' : 'none';
      if (isCustom) {
        palettePreview.style.background = buildCustomGradientCSS();
      } else {
        palettePreview.style.background = buildPalettePreviewGradient(state.palette);
      }
      renderMandelbrot();
      scheduleJuliaRender(false);
    });

    // Presets
    document.querySelectorAll('.preset-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        if (state.animation.active) return;
        state.c.re = parseFloat(btn.dataset.re);
        state.c.im = parseFloat(btn.dataset.im);
        cRealInput.value = state.c.re;
        cImagInput.value = state.c.im;
        updateCDisplay(state.c);
        drawMandelbrotCrosshair();
        scheduleJuliaRender(false);
      });
    });

    // Reset view
    function resetView() {
      state.julia.center = { re: 0, im: 0 };
      state.julia.zoom = 4;
      updateViewInfo();
      scheduleJuliaRender(false);
    }

    document.getElementById('btn-reset').addEventListener('click', resetView);
    document.getElementById('btn-reset-view').addEventListener('click', resetView);

    // Fullscreen
    function toggleFullscreen() {
      state.fullscreen = !state.fullscreen;
      document.body.classList.toggle('fullscreen-mode', state.fullscreen);
      setTimeout(() => {
        resizeCanvases();
        renderMandelbrot();
        scheduleJuliaRender(false);
      }, 50);
    }

    document.getElementById('btn-fullscreen').addEventListener('click', toggleFullscreen);
    document.getElementById('fullscreen-exit').addEventListener('click', toggleFullscreen);

    // Animation controls
    animBtn.addEventListener('click', () => {
      state.animation.active = !state.animation.active;
      animBtn.textContent = state.animation.active ? 'Pause' : 'Play';
      animBtn.classList.toggle('active', state.animation.active);
      if (state.animation.active) {
        animationLoop();
      }
    });

    animPath.addEventListener('change', () => {
      state.animation.path = animPath.value;
      state.animation.t = 0;
    });

    animSpeed.addEventListener('input', () => {
      state.animation.speed = parseFloat(animSpeed.value);
      speedVal.textContent = animSpeed.value;
    });

    // ================================================================
    // === CUSTOM GRADIENT EDITOR ===
    // ================================================================
    const geBar = document.getElementById('ge-bar');
    const geStopsEl = document.getElementById('ge-stops');
    const geColor = document.getElementById('ge-color');
    const gePosVal = document.getElementById('ge-pos-val');
    const geEditor = document.getElementById('gradient-editor');
    const geNameInput = document.getElementById('ge-name');
    const geSavedList = document.getElementById('ge-saved-list');
    const STORAGE_KEY = 'juliaExplorerCustomPalettes';

    function rgbToHex(r, g, b) {
      return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
    }

    function hexToRgb(hex) {
      return [parseInt(hex.slice(1, 3), 16), parseInt(hex.slice(3, 5), 16), parseInt(hex.slice(5, 7), 16)];
    }

    function sortStops() {
      state.customGradient.stops.sort((a, b) => a.pos - b.pos);
    }

    function buildCustomGradientCSS() {
      const stops = state.customGradient.stops;
      if (stops.length === 0) return 'linear-gradient(to right, #000, #000)';
      if (stops.length === 1) {
        const hex = rgbToHex(...stops[0].color);
        return `linear-gradient(to right, ${hex}, ${hex})`;
      }
      const cssStops = stops.map(s =>
        `rgb(${s.color[0]},${s.color[1]},${s.color[2]}) ${(s.pos * 100).toFixed(1)}%`
      );
      return `linear-gradient(to right, ${cssStops.join(', ')})`;
    }

    function renderGradientEditor() {
      geBar.style.background = buildCustomGradientCSS();
      geStopsEl.innerHTML = '';
      const stops = state.customGradient.stops;
      const selIdx = state.customGradient.selectedIndex;

      stops.forEach((stop, i) => {
        const el = document.createElement('div');
        el.className = 'ge-stop' + (i === selIdx ? ' selected' : '');
        el.style.left = (stop.pos * 100) + '%';
        el.style.backgroundColor = rgbToHex(...stop.color);

        el.addEventListener('mousedown', (e) => {
          e.preventDefault();
          e.stopPropagation();
          state.customGradient.selectedIndex = i;
          geColor.value = rgbToHex(...stop.color);
          gePosVal.textContent = stop.pos.toFixed(2);
          renderGradientEditor();
          startStopDrag(i, e);
        });

        geStopsEl.appendChild(el);
      });

      if (state.palette === 'custom') {
        palettePreview.style.background = buildCustomGradientCSS();
      }
    }

    function startStopDrag(index, startEvent) {
      const barRect = geBar.getBoundingClientRect();
      const stop = state.customGradient.stops[index];

      function onMove(e) {
        stop.pos = Math.max(0, Math.min(1, (e.clientX - barRect.left) / barRect.width));
        sortStops();
        state.customGradient.selectedIndex = state.customGradient.stops.indexOf(stop);
        gePosVal.textContent = stop.pos.toFixed(2);
        renderGradientEditor();
        if (state.palette === 'custom') {
          scheduleJuliaRender(true);
          renderMandelbrot();
        }
      }

      function onUp() {
        window.removeEventListener('mousemove', onMove);
        window.removeEventListener('mouseup', onUp);
        if (state.palette === 'custom') {
          scheduleJuliaRender(false);
          renderMandelbrot();
        }
      }

      window.addEventListener('mousemove', onMove);
      window.addEventListener('mouseup', onUp);
    }

    geBar.addEventListener('click', (e) => {
      const rect = geBar.getBoundingClientRect();
      const pos = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
      const color = palettes.custom(pos * 50);
      state.customGradient.stops.push({ pos, color: [...color] });
      sortStops();
      state.customGradient.selectedIndex = state.customGradient.stops.findIndex(s => s.pos === pos);
      geColor.value = rgbToHex(...color);
      gePosVal.textContent = pos.toFixed(2);
      renderGradientEditor();
      if (state.palette === 'custom') {
        scheduleJuliaRender(false);
        renderMandelbrot();
      }
    });

    geColor.addEventListener('input', () => {
      const idx = state.customGradient.selectedIndex;
      if (idx < 0 || idx >= state.customGradient.stops.length) return;
      state.customGradient.stops[idx].color = hexToRgb(geColor.value);
      renderGradientEditor();
      if (state.palette === 'custom') {
        scheduleJuliaRender(true);
        renderMandelbrot();
      }
    });

    geColor.addEventListener('change', () => {
      if (state.palette === 'custom') scheduleJuliaRender(false);
    });

    document.getElementById('ge-add-stop').addEventListener('click', () => {
      const stops = state.customGradient.stops;
      const idx = state.customGradient.selectedIndex;
      const next = Math.min(idx + 1, stops.length - 1);
      const pos = idx === next ? Math.min(1, stops[idx].pos + 0.1) : (stops[idx].pos + stops[next].pos) / 2;
      const color = hexToRgb(geColor.value);
      stops.push({ pos, color });
      sortStops();
      state.customGradient.selectedIndex = stops.findIndex(s => s.pos === pos && s.color === color);
      renderGradientEditor();
      if (state.palette === 'custom') {
        scheduleJuliaRender(false);
        renderMandelbrot();
      }
    });

    document.getElementById('ge-del-stop').addEventListener('click', () => {
      const stops = state.customGradient.stops;
      if (stops.length <= 2) return;
      const idx = state.customGradient.selectedIndex;
      stops.splice(idx, 1);
      state.customGradient.selectedIndex = Math.min(idx, stops.length - 1);
      const sel = stops[state.customGradient.selectedIndex];
      geColor.value = rgbToHex(...sel.color);
      gePosVal.textContent = sel.pos.toFixed(2);
      renderGradientEditor();
      if (state.palette === 'custom') {
        scheduleJuliaRender(false);
        renderMandelbrot();
      }
    });

    function loadSavedGradients() {
      try { return JSON.parse(localStorage.getItem(STORAGE_KEY)) || {}; }
      catch { return {}; }
    }

    function savePalettesToStorage(map) {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(map));
    }

    function renderSavedList() {
      const saved = loadSavedGradients();
      const names = Object.keys(saved);
      geSavedList.innerHTML = '';

      if (names.length === 0) {
        geSavedList.innerHTML = '<div class="ge-empty">No saved gradients yet</div>';
        return;
      }

      names.forEach(name => {
        const row = document.createElement('div');
        row.className = 'ge-saved-row';

        const preview = document.createElement('div');
        preview.className = 'ge-saved-preview';
        const cssStops = saved[name].map(s =>
          `rgb(${s.color[0]},${s.color[1]},${s.color[2]}) ${(s.pos * 100).toFixed(1)}%`
        );
        preview.style.background = `linear-gradient(to right, ${cssStops.join(', ')})`;

        const label = document.createElement('span');
        label.className = 'ge-saved-name';
        label.textContent = name;

        const loadBtn = document.createElement('button');
        loadBtn.className = 'ge-saved-btn';
        loadBtn.textContent = 'Use';
        loadBtn.addEventListener('click', () => {
          state.customGradient.stops = saved[name].map(s => ({ pos: s.pos, color: [...s.color] }));
          state.customGradient.selectedIndex = 0;
          sortStops();
          const sel = state.customGradient.stops[0];
          geColor.value = rgbToHex(...sel.color);
          gePosVal.textContent = sel.pos.toFixed(2);
          renderGradientEditor();
          if (state.palette === 'custom') {
            scheduleJuliaRender(false);
            renderMandelbrot();
          }
        });

        const delBtn = document.createElement('button');
        delBtn.className = 'ge-saved-btn ge-saved-btn-del';
        delBtn.textContent = '\u00d7';
        delBtn.title = 'Delete gradient';
        delBtn.addEventListener('click', () => {
          const all = loadSavedGradients();
          delete all[name];
          savePalettesToStorage(all);
          renderSavedList();
        });

        row.appendChild(preview);
        row.appendChild(label);
        row.appendChild(loadBtn);
        row.appendChild(delBtn);
        geSavedList.appendChild(row);
      });
    }

    document.getElementById('ge-save').addEventListener('click', () => {
      const name = geNameInput.value.trim();
      if (!name) {
        geNameInput.style.borderColor = '#ff5252';
        setTimeout(() => { geNameInput.style.borderColor = ''; }, 1200);
        return;
      }
      const all = loadSavedGradients();
      all[name] = state.customGradient.stops.map(s => ({ pos: s.pos, color: [...s.color] }));
      savePalettesToStorage(all);
      geNameInput.value = '';
      renderSavedList();
    });

    function initGradientEditor() {
      const sel = state.customGradient.stops[0];
      geColor.value = rgbToHex(...sel.color);
      gePosVal.textContent = sel.pos.toFixed(2);
      renderGradientEditor();
      renderSavedList();
    }

    // ================================================================
    // === ANIMATION LOOP ===
    // ================================================================
    let animRAF = null;

    function animationLoop() {
      if (!state.animation.active) return;

      state.animation.t = (state.animation.t + state.animation.speed) % 1;
      const pathFn = animPaths[state.animation.path];
      const newC = pathFn(state.animation.t);
      state.c = newC;
      state.tempC = null;

      cRealInput.value = newC.re.toFixed(4);
      cImagInput.value = newC.im.toFixed(4);
      updateCDisplay(newC);
      drawMandelbrotCrosshair();

      renderJulia(2);

      animRAF = requestAnimationFrame(animationLoop);
    }

    // ================================================================
    // === UI UPDATES ===
    // ================================================================
    function formatComplex(re, im) {
      const reStr = re.toFixed(4);
      const imAbs = Math.abs(im).toFixed(4);
      const sign = im >= 0 ? '+' : '\u2212';
      return `${reStr} ${sign} ${imAbs}i`;
    }

    function updateCDisplay(c) {
      cDisplay.textContent = `c = ${formatComplex(c.re, c.im)}`;
    }

    function updateViewInfo() {
      const baseZoom = 4;
      const zoomLevel = baseZoom / state.julia.zoom;
      zoomVal.textContent = zoomLevel >= 100 ? zoomLevel.toFixed(0) + 'x'
        : zoomLevel >= 10 ? zoomLevel.toFixed(1) + 'x'
        : zoomLevel.toFixed(2) + 'x';
      centerVal.textContent = `${state.julia.center.re.toFixed(4)}, ${state.julia.center.im.toFixed(4)}`;
    }

    // ================================================================
    // === INITIALIZATION ===
    // ================================================================
    function init() {
      resizeCanvases();
      palettePreview.style.background = buildPalettePreviewGradient(state.palette);
      updateCDisplay(state.c);
      updateViewInfo();
      initGradientEditor();
      renderMandelbrot();
      scheduleJuliaRender(false);
    }

    window.addEventListener('resize', () => {
      resizeCanvases();
      renderMandelbrot();
      scheduleJuliaRender(false);
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && state.fullscreen) {
        toggleFullscreen();
      }
      if (e.key === ' ' && document.activeElement === document.body) {
        e.preventDefault();
        animBtn.click();
      }
    });

    init();
  </script>
</body>
</html>
