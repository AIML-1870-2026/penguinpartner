<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Turing Patterns Studio</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * { box-sizing: border-box; }
        body {
            background: #0f0f0f;
            color: #e0e0e0;
            font-family: 'Inter', system-ui, sans-serif;
        }
        .panel { background: #1a1a1a; border-radius: 12px; }
        .panel-section { border-bottom: 1px solid #2a2a2a; }
        .btn {
            transition: all 0.2s ease;
            background: #2a2a2a;
        }
        .btn:hover { background: #3a3a3a; }
        .btn.active { background: #4f46e5; color: white; }
        .preset-btn {
            transition: all 0.15s ease;
            border: 2px solid transparent;
        }
        .preset-btn:hover { border-color: #4f46e5; }
        .preset-btn.active { border-color: #4f46e5; background: #2a2a2a; }
        .color-swatch {
            transition: transform 0.15s ease;
            border: 2px solid transparent;
        }
        .color-swatch:hover { transform: scale(1.1); }
        .color-swatch.active { border-color: white; }
        input[type="range"] {
            -webkit-appearance: none;
            background: #2a2a2a;
            border-radius: 4px;
            height: 6px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #4f46e5;
            border-radius: 50%;
            cursor: pointer;
        }
        select {
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            color: #e0e0e0;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
        }
        select:focus { outline: none; border-color: #4f46e5; }
        .section-title {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #888;
            margin-bottom: 8px;
        }
        #canvas {
            cursor: crosshair;
            border-radius: 8px;
        }
        .collapsible-header {
            cursor: pointer;
            user-select: none;
        }
        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }
        .collapsible-content.open {
            max-height: 300px;
        }
        .gradient-stop {
            width: 20px;
            height: 20px;
            border: 2px solid white;
            border-radius: 50%;
            cursor: grab;
            position: absolute;
            transform: translate(-50%, -50%);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        .gradient-stop:active { cursor: grabbing; }
        .modal {
            backdrop-filter: blur(4px);
        }
        .checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }
        .checkbox-wrapper input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: #4f46e5;
            cursor: pointer;
        }
    </style>
</head>
<body class="min-h-screen overflow-hidden">
    <!-- Header -->
    <header class="px-6 py-4 flex items-center justify-between border-b border-gray-800">
        <div>
            <h1 class="text-xl font-semibold text-white">Turing Patterns Studio</h1>
            <p class="text-sm text-gray-500">Create mesmerizing reaction-diffusion art</p>
        </div>
        <button id="infoBtn" class="btn px-4 py-2 rounded-lg text-sm flex items-center gap-2">
            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
            </svg>
            About
        </button>
    </header>

    <div class="flex h-[calc(100vh-73px)]">
        <!-- Main Canvas Area -->
        <div class="flex-1 flex items-center justify-center p-6">
            <div class="relative">
                <canvas id="canvas" width="512" height="512"></canvas>
                <div id="brushCursor" class="pointer-events-none absolute rounded-full border-2 border-white/50 hidden" style="transform: translate(-50%, -50%);"></div>
            </div>
        </div>

        <!-- Right Control Panel -->
        <div class="w-80 panel m-3 ml-0 overflow-y-auto">
            <!-- Presets Section -->
            <div class="panel-section p-4">
                <div class="section-title">Pattern Presets</div>
                <div id="presetGrid" class="grid grid-cols-2 gap-2"></div>
            </div>

            <!-- Drawing Section -->
            <div class="panel-section p-4">
                <div class="section-title">Drawing</div>
                <div class="flex items-center gap-2 mb-3">
                    <span class="text-sm text-gray-400">Brush Size:</span>
                    <div class="flex gap-1">
                        <button id="sizeS" class="btn px-3 py-1 rounded text-xs font-bold">S</button>
                        <button id="sizeM" class="btn px-3 py-1 rounded text-xs font-bold active">M</button>
                        <button id="sizeL" class="btn px-3 py-1 rounded text-xs font-bold">L</button>
                    </div>
                </div>
                <button id="clearBtn" class="btn w-full py-2 rounded-lg text-sm">Clear Canvas</button>
            </div>

            <!-- Symmetry Section -->
            <div class="panel-section p-4">
                <div class="section-title">Symmetry</div>
                <select id="symmetrySelect" class="w-full">
                    <option value="none">None</option>
                    <option value="h-mirror">Mirror Horizontal</option>
                    <option value="v-mirror">Mirror Vertical</option>
                    <option value="radial-4">Radial 4-way</option>
                    <option value="radial-8">Radial 8-way</option>
                </select>
            </div>

            <!-- Morph Section -->
            <div class="panel-section p-4">
                <div class="collapsible-header flex items-center justify-between" id="morphHeader">
                    <div class="section-title mb-0">Pattern Morphing</div>
                    <svg id="morphArrow" class="w-4 h-4 transform transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/>
                    </svg>
                </div>
                <div id="morphContent" class="collapsible-content">
                    <div class="pt-3 space-y-3">
                        <div>
                            <label class="text-xs text-gray-400 block mb-1">From:</label>
                            <select id="morphFromSelect" class="w-full text-sm"></select>
                        </div>
                        <div>
                            <label class="text-xs text-gray-400 block mb-1">To:</label>
                            <select id="morphToSelect" class="w-full text-sm"></select>
                        </div>
                        <div>
                            <label class="text-xs text-gray-400 block mb-1">Blend: <span id="morphVal">0</span>%</label>
                            <input type="range" id="morphSlider" min="0" max="100" value="0" class="w-full">
                        </div>
                        <label class="checkbox-wrapper text-sm">
                            <input type="checkbox" id="autoMorph">
                            <span>Auto-morph</span>
                        </label>
                    </div>
                </div>
            </div>

            <!-- Color Section -->
            <div class="panel-section p-4">
                <div class="section-title">Color Palette</div>
                <div id="colorPalettes" class="grid grid-cols-3 gap-2 mb-3"></div>
                <button id="customGradientBtn" class="btn w-full py-2 rounded-lg text-sm">Custom Gradient</button>
            </div>

            <!-- Effects Section -->
            <div class="panel-section p-4">
                <div class="section-title">Effects</div>
                <label class="checkbox-wrapper text-sm mb-3">
                    <input type="checkbox" id="rotateEffect">
                    <span>Rotate Pattern</span>
                </label>
                <div>
                    <label class="text-sm text-gray-400 block mb-1">Speed: <span id="speedVal">1.0</span>x</label>
                    <input type="range" id="speed" min="5" max="20" step="1" value="10" class="w-full">
                </div>
            </div>

            <!-- Controls Section -->
            <div class="p-4">
                <div class="section-title">Controls</div>
                <div class="grid grid-cols-2 gap-2">
                    <button id="playPauseBtn" class="btn py-2 rounded-lg text-sm flex items-center justify-center gap-2">
                        <svg id="playIcon" class="w-4 h-4 hidden" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M8 5v14l11-7z"/>
                        </svg>
                        <svg id="pauseIcon" class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"/>
                        </svg>
                        <span id="playPauseText">Pause</span>
                    </button>
                    <button id="resetBtn" class="btn py-2 rounded-lg text-sm">Reset</button>
                    <button id="randomizeBtn" class="btn py-2 rounded-lg text-sm col-span-2">Randomize Seeds</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Info Modal -->
    <div id="infoModal" class="modal fixed inset-0 bg-black/80 hidden items-center justify-center z-50">
        <div class="panel p-6 max-w-lg mx-4">
            <h3 class="text-lg font-semibold mb-4">About Turing Patterns</h3>
            <p class="text-gray-300 mb-3">
                Turing patterns are mathematical models describing how patterns emerge in nature through chemical reactions and diffusion. First proposed by Alan Turing in 1952.
            </p>
            <p class="text-gray-300 mb-3">
                This simulation uses the Gray-Scott model with two virtual chemicals that react and diffuse across the canvas.
            </p>
            <p class="text-gray-300 mb-4">
                <strong>Tips:</strong><br>
                - Click and drag to add seeds<br>
                - Try different presets for unique patterns<br>
                - Use symmetry for kaleidoscope effects<br>
                - Morph between presets for hybrid patterns
            </p>
            <button id="closeInfo" class="btn w-full py-2 rounded-lg">Close</button>
        </div>
    </div>

    <!-- Gradient Editor Modal -->
    <div id="gradientModal" class="modal fixed inset-0 bg-black/80 hidden items-center justify-center z-50">
        <div class="panel p-6 w-96 mx-4">
            <h3 class="text-lg font-semibold mb-4">Custom Gradient</h3>
            <div id="gradientPreview" class="h-12 rounded-lg mb-4 relative" style="background: linear-gradient(to right, #000, #fff);"></div>
            <div id="gradientBar" class="h-8 rounded relative cursor-pointer mb-4" style="background: linear-gradient(to right, #000, #fff);"></div>
            <div class="mb-4">
                <label class="text-sm text-gray-400 block mb-2">Selected Stop Color:</label>
                <input type="color" id="stopColor" value="#ffffff" class="w-full h-10 rounded cursor-pointer">
            </div>
            <p class="text-xs text-gray-500 mb-4">Click on the gradient bar to add stops. Drag stops to reposition. Double-click to remove.</p>
            <div class="flex gap-2">
                <button id="cancelGradient" class="btn flex-1 py-2 rounded-lg text-sm">Cancel</button>
                <button id="saveGradient" class="btn flex-1 py-2 rounded-lg text-sm bg-indigo-600 hover:bg-indigo-700">Save</button>
            </div>
        </div>
    </div>

    <script>
        // ========== CONFIGURATION ==========
        const PRESETS = {
            spots: { name: 'Spots', f: 0.055, k: 0.062 },
            stripes: { name: 'Stripes', f: 0.035, k: 0.060 },
            spirals: { name: 'Spirals', f: 0.014, k: 0.054 },
            coral: { name: 'Coral', f: 0.0545, k: 0.062 },
            worms: { name: 'Worms', f: 0.058, k: 0.065 },
            waves: { name: 'Waves', f: 0.018, k: 0.051 },
            fingerprint: { name: 'Fingerprint', f: 0.029, k: 0.057 },
            maze: { name: 'Maze', f: 0.029, k: 0.057 }
        };

        const PALETTES = {
            grayscale: { name: 'Grayscale', colors: [[0,0,0], [128,128,128], [255,255,255]] },
            ocean: { name: 'Ocean', colors: [[10,25,50], [30,80,120], [50,150,180], [150,220,230], [255,255,255]] },
            fire: { name: 'Fire', colors: [[0,0,0], [139,0,0], [255,69,0], [255,165,0], [255,255,0]] },
            forest: { name: 'Forest', colors: [[10,40,20], [30,80,40], [50,140,70], [100,200,120], [200,255,200]] },
            sunset: { name: 'Sunset', colors: [[40,20,80], [120,40,100], [200,80,80], [255,150,50], [255,220,100]] },
            neon: { name: 'Neon', colors: [[0,0,0], [80,0,120], [200,0,200], [0,200,255], [255,255,255]] }
        };

        // ========== STATE ==========
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const width = canvas.width;
        const height = canvas.height;

        let gridA = new Float32Array(width * height);
        let gridB = new Float32Array(width * height);
        let nextA = new Float32Array(width * height);
        let nextB = new Float32Array(width * height);

        let currentPreset = 'spots';
        let f = PRESETS.spots.f;
        let k = PRESETS.spots.k;
        const dA = 1.0;
        const dB = 0.5;

        let currentPalette = 'ocean';
        let customGradient = null;
        let paused = false;
        let brushSize = 10;
        let simSpeed = 10;
        let symmetryMode = 'none';
        let rotateEnabled = false;
        let rotationAngle = 0;

        // Morph state
        let morphFrom = 'spots';
        let morphTo = 'stripes';
        let morphValue = 0;
        let autoMorphEnabled = false;
        let autoMorphDirection = 1;

        // Gradient editor state
        let gradientStops = [
            { pos: 0, color: '#000000' },
            { pos: 1, color: '#ffffff' }
        ];
        let selectedStop = null;

        // ========== INITIALIZATION ==========
        function initGrid() {
            for (let i = 0; i < width * height; i++) {
                gridA[i] = 1.0;
                gridB[i] = 0.0;
            }
            // Add random seeds
            const numSeeds = 20 + Math.floor(Math.random() * 20);
            for (let s = 0; s < numSeeds; s++) {
                const cx = Math.floor(Math.random() * width);
                const cy = Math.floor(Math.random() * height);
                const r = 3 + Math.floor(Math.random() * 6);
                addSeed(cx, cy, r);
            }
        }

        function addSeed(cx, cy, radius) {
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    if (dx*dx + dy*dy <= radius*radius) {
                        const x = (cx + dx + width) % width;
                        const y = (cy + dy + height) % height;
                        const idx = y * width + x;
                        gridA[idx] = 0.0;
                        gridB[idx] = 1.0;
                    }
                }
            }
        }

        function clearGrid() {
            for (let i = 0; i < width * height; i++) {
                gridA[i] = 1.0;
                gridB[i] = 0.0;
            }
        }

        // ========== SIMULATION ==========
        function simulate() {
            // Update f and k based on morph value
            if (morphValue > 0) {
                const fromPreset = PRESETS[morphFrom];
                const toPreset = PRESETS[morphTo];
                const t = morphValue / 100;
                f = fromPreset.f + (toPreset.f - fromPreset.f) * t;
                k = fromPreset.k + (toPreset.k - fromPreset.k) * t;
            }

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = y * width + x;

                    // Get neighbors with wrapping
                    const left = y * width + ((x - 1 + width) % width);
                    const right = y * width + ((x + 1) % width);
                    const up = ((y - 1 + height) % height) * width + x;
                    const down = ((y + 1) % height) * width + x;

                    // Laplacian
                    const laplaceA = gridA[left] + gridA[right] + gridA[up] + gridA[down] - 4 * gridA[idx];
                    const laplaceB = gridB[left] + gridB[right] + gridB[up] + gridB[down] - 4 * gridB[idx];

                    // Gray-Scott equations
                    const a = gridA[idx];
                    const b = gridB[idx];
                    const abb = a * b * b;

                    nextA[idx] = a + (dA * laplaceA - abb + f * (1 - a));
                    nextB[idx] = b + (dB * laplaceB + abb - (k + f) * b);

                    // Clamp values
                    nextA[idx] = Math.max(0, Math.min(1, nextA[idx]));
                    nextB[idx] = Math.max(0, Math.min(1, nextB[idx]));
                }
            }

            // Swap buffers
            [gridA, nextA] = [nextA, gridA];
            [gridB, nextB] = [nextB, gridB];
        }

        // ========== RENDERING ==========
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? [
                parseInt(result[1], 16),
                parseInt(result[2], 16),
                parseInt(result[3], 16)
            ] : [0, 0, 0];
        }

        function getColor(value) {
            let colors;
            if (customGradient) {
                colors = customGradient.map(stop => hexToRgb(stop.color));
                const positions = customGradient.map(stop => stop.pos);

                const t = Math.max(0, Math.min(1, value));
                for (let i = 0; i < positions.length - 1; i++) {
                    if (t >= positions[i] && t <= positions[i + 1]) {
                        const localT = (t - positions[i]) / (positions[i + 1] - positions[i]);
                        const c1 = colors[i];
                        const c2 = colors[i + 1];
                        return [
                            Math.round(c1[0] + (c2[0] - c1[0]) * localT),
                            Math.round(c1[1] + (c2[1] - c1[1]) * localT),
                            Math.round(c1[2] + (c2[2] - c1[2]) * localT)
                        ];
                    }
                }
                return colors[colors.length - 1];
            } else {
                colors = PALETTES[currentPalette].colors;
                const t = Math.max(0, Math.min(1, value));
                const scaledT = t * (colors.length - 1);
                const i = Math.floor(scaledT);
                const frac = scaledT - i;

                if (i >= colors.length - 1) return colors[colors.length - 1];

                const c1 = colors[i];
                const c2 = colors[i + 1];

                return [
                    Math.round(c1[0] + (c2[0] - c1[0]) * frac),
                    Math.round(c1[1] + (c2[1] - c1[1]) * frac),
                    Math.round(c1[2] + (c2[2] - c1[2]) * frac)
                ];
            }
        }

        function render() {
            const imageData = ctx.createImageData(width, height);
            const data = imageData.data;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    let sampleX = x;
                    let sampleY = y;

                    // Apply rotation
                    if (rotateEnabled) {
                        const cx = width / 2;
                        const cy = height / 2;
                        const cos = Math.cos(rotationAngle);
                        const sin = Math.sin(rotationAngle);
                        const dx = x - cx;
                        const dy = y - cy;
                        sampleX = Math.floor(cx + dx * cos - dy * sin + width) % width;
                        sampleY = Math.floor(cy + dx * sin + dy * cos + height) % height;
                    }

                    const idx = sampleY * width + sampleX;
                    const color = getColor(gridB[idx]);
                    const outIdx = (y * width + x) * 4;
                    data[outIdx] = color[0];
                    data[outIdx + 1] = color[1];
                    data[outIdx + 2] = color[2];
                    data[outIdx + 3] = 255;
                }
            }

            ctx.putImageData(imageData, 0, 0);
        }

        // ========== INTERACTION ==========
        function applyBrushAtPoint(cx, cy) {
            const r = brushSize;
            for (let dy = -r; dy <= r; dy++) {
                for (let dx = -r; dx <= r; dx++) {
                    if (dx*dx + dy*dy <= r*r) {
                        const px = (cx + dx + width) % width;
                        const py = (cy + dy + height) % height;
                        const idx = py * width + px;
                        gridA[idx] = 0.0;
                        gridB[idx] = 1.0;
                    }
                }
            }
        }

        function applyBrush(canvasX, canvasY) {
            const cx = Math.floor(canvasX);
            const cy = Math.floor(canvasY);

            // Apply based on symmetry mode
            switch (symmetryMode) {
                case 'none':
                    applyBrushAtPoint(cx, cy);
                    break;
                case 'h-mirror':
                    applyBrushAtPoint(cx, cy);
                    applyBrushAtPoint(width - cx, cy);
                    break;
                case 'v-mirror':
                    applyBrushAtPoint(cx, cy);
                    applyBrushAtPoint(cx, height - cy);
                    break;
                case 'radial-4':
                    applyBrushAtPoint(cx, cy);
                    applyBrushAtPoint(width - cx, cy);
                    applyBrushAtPoint(cx, height - cy);
                    applyBrushAtPoint(width - cx, height - cy);
                    break;
                case 'radial-8':
                    const mcx = width / 2;
                    const mcy = height / 2;
                    const dx = cx - mcx;
                    const dy = cy - mcy;
                    for (let i = 0; i < 8; i++) {
                        const angle = (i * Math.PI) / 4;
                        const cos = Math.cos(angle);
                        const sin = Math.sin(angle);
                        const nx = Math.floor(mcx + dx * cos - dy * sin + width) % width;
                        const ny = Math.floor(mcy + dx * sin + dy * cos + height) % height;
                        applyBrushAtPoint(nx, ny);
                    }
                    break;
            }
        }

        // ========== ANIMATION LOOP ==========
        function animate() {
            if (!paused) {
                for (let i = 0; i < simSpeed; i++) {
                    simulate();
                }

                // Auto-morph
                if (autoMorphEnabled) {
                    morphValue += autoMorphDirection * 0.3;
                    if (morphValue >= 100) {
                        morphValue = 100;
                        autoMorphDirection = -1;
                    } else if (morphValue <= 0) {
                        morphValue = 0;
                        autoMorphDirection = 1;
                    }
                    document.getElementById('morphSlider').value = morphValue;
                    document.getElementById('morphVal').textContent = Math.round(morphValue);
                }

                // Rotation
                if (rotateEnabled) {
                    rotationAngle += 0.002;
                }
            }
            render();
            requestAnimationFrame(animate);
        }

        // ========== UI SETUP ==========
        // Preset buttons
        const presetGrid = document.getElementById('presetGrid');
        Object.entries(PRESETS).forEach(([key, preset]) => {
            const btn = document.createElement('button');
            btn.className = 'preset-btn p-2 rounded-lg text-center text-sm';
            btn.textContent = preset.name;
            if (key === currentPreset) btn.classList.add('active');
            btn.addEventListener('click', () => {
                document.querySelectorAll('.preset-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                currentPreset = key;
                f = PRESETS[key].f;
                k = PRESETS[key].k;
                morphValue = 0;
                document.getElementById('morphSlider').value = 0;
                document.getElementById('morphVal').textContent = '0';
            });
            presetGrid.appendChild(btn);
        });

        // Color palette buttons
        const colorPalettes = document.getElementById('colorPalettes');
        Object.entries(PALETTES).forEach(([key, palette]) => {
            const swatch = document.createElement('button');
            swatch.className = 'color-swatch w-full h-8 rounded-lg';
            const colors = palette.colors;
            const gradientStops = colors.map((c, i) => `rgb(${c[0]},${c[1]},${c[2]}) ${i * 100 / (colors.length-1)}%`).join(', ');
            swatch.style.background = `linear-gradient(90deg, ${gradientStops})`;
            swatch.title = palette.name;
            if (key === currentPalette) swatch.classList.add('active');
            swatch.addEventListener('click', () => {
                document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
                swatch.classList.add('active');
                currentPalette = key;
                customGradient = null;
            });
            colorPalettes.appendChild(swatch);
        });

        // Brush size
        const sizes = { S: 5, M: 10, L: 20 };
        ['S', 'M', 'L'].forEach(size => {
            document.getElementById('size' + size).addEventListener('click', () => {
                brushSize = sizes[size];
                ['S', 'M', 'L'].forEach(s => document.getElementById('size' + s).classList.remove('active'));
                document.getElementById('size' + size).classList.add('active');
            });
        });

        // Speed slider
        document.getElementById('speed').addEventListener('input', (e) => {
            simSpeed = parseInt(e.target.value);
            document.getElementById('speedVal').textContent = (simSpeed / 10).toFixed(1);
        });

        // Symmetry
        document.getElementById('symmetrySelect').addEventListener('change', (e) => {
            symmetryMode = e.target.value;
        });

        // Morph controls
        const morphFromSelect = document.getElementById('morphFromSelect');
        const morphToSelect = document.getElementById('morphToSelect');
        Object.entries(PRESETS).forEach(([key, preset]) => {
            const opt1 = document.createElement('option');
            opt1.value = key;
            opt1.textContent = preset.name;
            if (key === morphFrom) opt1.selected = true;
            morphFromSelect.appendChild(opt1);

            const opt2 = document.createElement('option');
            opt2.value = key;
            opt2.textContent = preset.name;
            if (key === morphTo) opt2.selected = true;
            morphToSelect.appendChild(opt2);
        });

        morphFromSelect.addEventListener('change', (e) => morphFrom = e.target.value);
        morphToSelect.addEventListener('change', (e) => morphTo = e.target.value);

        document.getElementById('morphSlider').addEventListener('input', (e) => {
            morphValue = parseInt(e.target.value);
            document.getElementById('morphVal').textContent = morphValue;
        });

        document.getElementById('autoMorph').addEventListener('change', (e) => {
            autoMorphEnabled = e.target.checked;
        });

        // Morph collapsible
        document.getElementById('morphHeader').addEventListener('click', () => {
            const content = document.getElementById('morphContent');
            const arrow = document.getElementById('morphArrow');
            content.classList.toggle('open');
            arrow.classList.toggle('rotate-180');
        });

        // Rotate effect
        document.getElementById('rotateEffect').addEventListener('change', (e) => {
            rotateEnabled = e.target.checked;
            if (!rotateEnabled) rotationAngle = 0;
        });

        // Control buttons
        document.getElementById('playPauseBtn').addEventListener('click', () => {
            paused = !paused;
            document.getElementById('playPauseText').textContent = paused ? 'Play' : 'Pause';
            document.getElementById('playIcon').classList.toggle('hidden', !paused);
            document.getElementById('pauseIcon').classList.toggle('hidden', paused);
        });
        document.getElementById('resetBtn').addEventListener('click', initGrid);
        document.getElementById('randomizeBtn').addEventListener('click', initGrid);
        document.getElementById('clearBtn').addEventListener('click', clearGrid);

        // Canvas interaction
        let isDrawing = false;

        function getCanvasCoords(e) {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * (width / rect.width);
            const y = (e.clientY - rect.top) * (height / rect.height);
            return { x, y };
        }

        canvas.addEventListener('mousedown', (e) => {
            isDrawing = true;
            const { x, y } = getCanvasCoords(e);
            applyBrush(x, y);
        });

        canvas.addEventListener('mousemove', (e) => {
            const { x, y } = getCanvasCoords(e);

            // Update brush cursor
            const cursor = document.getElementById('brushCursor');
            const rect = canvas.getBoundingClientRect();
            cursor.style.left = e.clientX - rect.left + canvas.offsetLeft + 'px';
            cursor.style.top = e.clientY - rect.top + canvas.offsetTop + 'px';
            cursor.style.width = brushSize * 2 * (rect.width / width) + 'px';
            cursor.style.height = brushSize * 2 * (rect.height / height) + 'px';
            cursor.classList.remove('hidden');

            if (isDrawing) {
                applyBrush(x, y);
            }
        });

        canvas.addEventListener('mouseup', () => isDrawing = false);
        canvas.addEventListener('mouseleave', () => {
            isDrawing = false;
            document.getElementById('brushCursor').classList.add('hidden');
        });

        // Touch support
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = (touch.clientX - rect.left) * (width / rect.width);
            const y = (touch.clientY - rect.top) * (height / rect.height);
            applyBrush(x, y);
        }, { passive: false });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (isDrawing) {
                const rect = canvas.getBoundingClientRect();
                const touch = e.touches[0];
                const x = (touch.clientX - rect.left) * (width / rect.width);
                const y = (touch.clientY - rect.top) * (height / rect.height);
                applyBrush(x, y);
            }
        }, { passive: false });

        canvas.addEventListener('touchend', () => isDrawing = false);

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.key === ' ') { e.preventDefault(); document.getElementById('playPauseBtn').click(); }
            if (e.key === 'r') document.getElementById('resetBtn').click();
            if (e.key === 'c') document.getElementById('clearBtn').click();
        });

        // Info modal
        document.getElementById('infoBtn').addEventListener('click', () => {
            document.getElementById('infoModal').classList.remove('hidden');
            document.getElementById('infoModal').classList.add('flex');
        });
        document.getElementById('closeInfo').addEventListener('click', () => {
            document.getElementById('infoModal').classList.add('hidden');
            document.getElementById('infoModal').classList.remove('flex');
        });

        // ========== GRADIENT EDITOR ==========
        function updateGradientDisplay() {
            const sorted = [...gradientStops].sort((a, b) => a.pos - b.pos);
            const gradient = sorted.map(s => `${s.color} ${s.pos * 100}%`).join(', ');
            document.getElementById('gradientBar').style.background = `linear-gradient(to right, ${gradient})`;
            document.getElementById('gradientPreview').style.background = `linear-gradient(to right, ${gradient})`;
        }

        function renderGradientStops() {
            const bar = document.getElementById('gradientBar');
            // Remove existing stops
            bar.querySelectorAll('.gradient-stop').forEach(el => el.remove());

            gradientStops.forEach((stop, index) => {
                const el = document.createElement('div');
                el.className = 'gradient-stop';
                el.style.left = stop.pos * 100 + '%';
                el.style.top = '50%';
                el.style.background = stop.color;
                el.dataset.index = index;

                el.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    selectedStop = index;
                    document.getElementById('stopColor').value = gradientStops[index].color;
                });

                el.addEventListener('dblclick', (e) => {
                    e.stopPropagation();
                    if (gradientStops.length > 2) {
                        gradientStops.splice(index, 1);
                        renderGradientStops();
                        updateGradientDisplay();
                    }
                });

                bar.appendChild(el);
            });
        }

        document.getElementById('gradientBar').addEventListener('mousedown', (e) => {
            if (e.target.classList.contains('gradient-stop')) return;
            const rect = e.target.getBoundingClientRect();
            const pos = (e.clientX - rect.left) / rect.width;
            const color = document.getElementById('stopColor').value;
            gradientStops.push({ pos, color });
            renderGradientStops();
            updateGradientDisplay();
            selectedStop = gradientStops.length - 1;
        });

        document.getElementById('stopColor').addEventListener('input', (e) => {
            if (selectedStop !== null && gradientStops[selectedStop]) {
                gradientStops[selectedStop].color = e.target.value;
                renderGradientStops();
                updateGradientDisplay();
            }
        });

        // Drag stops
        let draggingStop = null;
        document.addEventListener('mousedown', (e) => {
            if (e.target.classList.contains('gradient-stop')) {
                draggingStop = parseInt(e.target.dataset.index);
            }
        });

        document.addEventListener('mousemove', (e) => {
            if (draggingStop !== null) {
                const bar = document.getElementById('gradientBar');
                const rect = bar.getBoundingClientRect();
                let pos = (e.clientX - rect.left) / rect.width;
                pos = Math.max(0, Math.min(1, pos));
                gradientStops[draggingStop].pos = pos;
                renderGradientStops();
                updateGradientDisplay();
            }
        });

        document.addEventListener('mouseup', () => {
            draggingStop = null;
        });

        document.getElementById('customGradientBtn').addEventListener('click', () => {
            gradientStops = [
                { pos: 0, color: '#000000' },
                { pos: 0.5, color: '#4f46e5' },
                { pos: 1, color: '#ffffff' }
            ];
            selectedStop = null;
            renderGradientStops();
            updateGradientDisplay();
            document.getElementById('gradientModal').classList.remove('hidden');
            document.getElementById('gradientModal').classList.add('flex');
        });

        document.getElementById('cancelGradient').addEventListener('click', () => {
            document.getElementById('gradientModal').classList.add('hidden');
            document.getElementById('gradientModal').classList.remove('flex');
        });

        document.getElementById('saveGradient').addEventListener('click', () => {
            const sorted = [...gradientStops].sort((a, b) => a.pos - b.pos);
            customGradient = sorted;
            document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('active'));
            document.getElementById('gradientModal').classList.add('hidden');
            document.getElementById('gradientModal').classList.remove('flex');
        });

        // ========== START ==========
        initGrid();
        animate();
        console.log('Turing Patterns Studio initialized!');
    </script>
</body>
</html>
